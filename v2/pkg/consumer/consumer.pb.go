// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consumer.proto

package consumer

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import protocol "github.com/LiveRamp/gazette/v2/pkg/protocol"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/golang/protobuf/ptypes/duration"

import github_com_LiveRamp_gazette_pkg_protocol "github.com/LiveRamp/gazette/v2/pkg/protocol"
import time "time"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Status is a response status code, used across Gazette Consumer RPC APIs.
type Status int32

const (
	Status_OK Status = 0
	// The named shard does not exist.
	Status_SHARD_NOT_FOUND Status = 1
	// There is no current primary consumer process for the shard. This is a
	// temporary condition which should quickly resolve, assuming sufficient
	// consumer capacity.
	Status_NO_SHARD_PRIMARY Status = 2
	// The present consumer process is not the assigned primary for the shard,
	// and was not instructed to proxy the request.
	Status_NOT_SHARD_PRIMARY Status = 3
	// The Etcd transaction failed. Returned by Update RPC when an
	// expect_mod_revision of the UpdateRequest differs from the current
	// ModRevision of the ShardSpec within the store.
	Status_ETCD_TRANSACTION_FAILED Status = 4
)

var Status_name = map[int32]string{
	0: "OK",
	1: "SHARD_NOT_FOUND",
	2: "NO_SHARD_PRIMARY",
	3: "NOT_SHARD_PRIMARY",
	4: "ETCD_TRANSACTION_FAILED",
}
var Status_value = map[string]int32{
	"OK":                      0,
	"SHARD_NOT_FOUND":         1,
	"NO_SHARD_PRIMARY":        2,
	"NOT_SHARD_PRIMARY":       3,
	"ETCD_TRANSACTION_FAILED": 4,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{0}
}

type ReplicaStatus_Code int32

const (
	ReplicaStatus_IDLE ReplicaStatus_Code = 0
	// The replica is actively playing the historical log.
	ReplicaStatus_BACKFILL ReplicaStatus_Code = 1
	// The replica has finished playing the historical log, and is tailing the
	// live log to locally mirror recorded operations as they are produced. It
	// is a "hot standby" and can take over as primary at any time.
	ReplicaStatus_TAILING ReplicaStatus_Code = 2
	// The replica is actively serving as primary.
	ReplicaStatus_PRIMARY ReplicaStatus_Code = 3
	// The replica has encountered an unrecoverable error.
	ReplicaStatus_FAILED ReplicaStatus_Code = 4
)

var ReplicaStatus_Code_name = map[int32]string{
	0: "IDLE",
	1: "BACKFILL",
	2: "TAILING",
	3: "PRIMARY",
	4: "FAILED",
}
var ReplicaStatus_Code_value = map[string]int32{
	"IDLE":     0,
	"BACKFILL": 1,
	"TAILING":  2,
	"PRIMARY":  3,
	"FAILED":   4,
}

func (x ReplicaStatus_Code) String() string {
	return proto.EnumName(ReplicaStatus_Code_name, int32(x))
}
func (ReplicaStatus_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{2, 0}
}

// ShardSpec describes a shard and its configuration. Shards represent the
// combination of a consumer application, a specific journal selected for
// consumption, and a recoverylog journal which replicates the stateful
// consumption of that journal by the consumer. ShardSpec serves as a
// allocator ItemValue.
type ShardSpec struct {
	// ID of the Shard.
	Id ShardID `protobuf:"bytes,1,opt,name=id,proto3,casttype=ShardID" json:"id,omitempty"`
	// Sources of the shard, uniquely ordered on Source journal.
	Sources []ShardSpec_Source `protobuf:"bytes,2,rep,name=sources" json:"sources"`
	// Recovery log into which the Shard's database is replicated.
	RecoveryLog github_com_LiveRamp_gazette_pkg_protocol.Journal `protobuf:"bytes,3,opt,name=recovery_log,json=recoveryLog,proto3,casttype=github.com/LiveRamp/gazette/pkg/protocol.Journal" json:"recovery_log,omitempty" yaml:"recovery_log"`
	// Etcd keys into which recoverylog.FSMHints are written to and read from.
	// FSMHints allow readers of the recoverylog to efficiently determine the
	// minimum fragments of log which must be read to fully recover database state.
	// The current primary will regularly produce updated hints into hint_keys[0].
	// New players of the log will similarly utilize hints from hint_keys[0].
	// At least one |hint_keys| must be provided.
	//
	// Additional hint_keys beyond the first are a disaster-recovery mechanism:
	// On completing playback, a player will write the hints it recovered to
	// hint_keys[1], shifting the prior value of hint_keys[1] => hint_keys[2],
	// and so on for as many |hint_keys| as are specified. In the case of disaster
	// data-loss, these copied hints can be a helpful fallback for recovering a
	// consistent albiet older version of the Shard database, relying on only
	// progressively older portions of the recoverylog.
	//
	// When pruning the recoverylog, log fragments which are older than and no
	// longer required by the *last* of |hint_keys| are discarded, ensuring that
	// all of |hint_keys| remain valid for playback.
	HintKeys []string `protobuf:"bytes,4,rep,name=hint_keys,json=hintKeys" json:"hint_keys,omitempty" yaml:"hint_keys"`
	// Max duration of shard transactions. This duration upper-bounds the amount
	// of time during which a transaction may process messages before it must flush
	// and commit. It may run for less time if an input message stall occurs (eg,
	// no decoded journal message is ready without blocking). A typical value
	// would be `1s`: applications which perform extensive aggregation over message
	// streams exhibiting locality of "hot" keys may benefit from larger values.
	MaxTxnDuration time.Duration `protobuf:"bytes,5,opt,name=max_txn_duration,json=maxTxnDuration,stdduration" json:"max_txn_duration" yaml:"max_txn_duration,omitempty"`
	// Min duration of shard transactions. This duration lower-bounds the amount
	// of time during which a transaction must process messages before it may flush
	// and commit. It may run for more time if additional messages are available
	// (eg, decoded journal messages are ready without blocking). Note also that
	// transactions are pipelined: a current transaction may process messages while
	// a prior transaction's recoverylog writes flush to Gazette, but it cannot
	// begin to commit until the prior transaction writes complete. In other words
	// even if |min_txn_quantum| is zero, some degree of message batching is
	// expected due to the network delay inherent in Gazette writes. A typical
	// value of would be `0s`: applications which perform extensive aggregation
	// may benefit from larger values.
	MinTxnDuration time.Duration `protobuf:"bytes,6,opt,name=min_txn_duration,json=minTxnDuration,stdduration" json:"min_txn_duration" yaml:"min_txn_duration,omitempty"`
	// Disable processing of the Shard.
	Disable bool `protobuf:"varint,7,opt,name=disable,proto3" json:"disable,omitempty"`
	// Hot standbys is the desired number of consumer processes which should be
	// replicating the primary consumer's recovery log. Standbys are allocated in
	// a separate availability zone of the current primary, and tail the live log
	// to continuously mirror the primary's on-disk DB file structure. Should the
	// primary experience failure, one of the hot standbys will be assigned to take
	// over as the new shard primary, which is accomplished by simply opening its
	// local copy of the RocksDB.
	//
	// Note that under regular operation, Shard hand-off is zero downtime even if
	// standbys are zero, as the current primary will not cede ownership until the
	// replacement process has completed log playback. However, a process failure
	// will leave the Shard without an owner until log playback can complete.
	HotStandbys uint32 `protobuf:"varint,8,opt,name=hot_standbys,json=hotStandbys,proto3" json:"hot_standbys,omitempty" yaml:"hot_standbys"`
	// User-defined Labels of this ShardSpec. The label "id" is reserved and may
	// not be used with a ShardSpec's labels.
	protocol.LabelSet `protobuf:"bytes,9,opt,name=labels,embedded=labels" json:"labels" yaml:",omitempty,inline"`
}

func (m *ShardSpec) Reset()         { *m = ShardSpec{} }
func (m *ShardSpec) String() string { return proto.CompactTextString(m) }
func (*ShardSpec) ProtoMessage()    {}
func (*ShardSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{0}
}
func (m *ShardSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ShardSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardSpec.Merge(dst, src)
}
func (m *ShardSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShardSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ShardSpec proto.InternalMessageInfo

// Sources define the set of Journals which this Shard consumes.
// At least one Source must be specified, and in many use cases only one will
// be needed. For advanced use cases which can benefit, multiple sources may
// be specified to represent a "join" over messages of distinct journals. Note
// the effective mapping of messages to each of the joined journals should
// align (eg, joining a journal of customer updates with one of orders, where
// both are mapped on customer ID). Another powerful pattern is to join each
// partition of a high-volume event stream with a low-volume journal of
// queries, obtaining a reliable distributed scatter/gather query engine.
type ShardSpec_Source struct {
	// Journal which this Shard is consuming.
	Journal github_com_LiveRamp_gazette_pkg_protocol.Journal `protobuf:"bytes,1,opt,name=journal,proto3,casttype=github.com/LiveRamp/gazette/pkg/protocol.Journal" json:"journal,omitempty"`
	// Minimum journal byte offset the shard should begin reading from. Typically
	// this should be zero, as read offsets are persisted to and recovered from
	// the shard store as the journal is processed. |min_offset| can be useful
	// for shard initialization, directing it to skip over undesired historical
	// sections of the journal.
	MinOffset int64 `protobuf:"varint,3,opt,name=min_offset,json=minOffset,proto3" json:"min_offset,omitempty" yaml:"min_offset,omitempty"`
}

func (m *ShardSpec_Source) Reset()         { *m = ShardSpec_Source{} }
func (m *ShardSpec_Source) String() string { return proto.CompactTextString(m) }
func (*ShardSpec_Source) ProtoMessage()    {}
func (*ShardSpec_Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{0, 0}
}
func (m *ShardSpec_Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardSpec_Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardSpec_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ShardSpec_Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardSpec_Source.Merge(dst, src)
}
func (m *ShardSpec_Source) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShardSpec_Source) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardSpec_Source.DiscardUnknown(m)
}

var xxx_messageInfo_ShardSpec_Source proto.InternalMessageInfo

// ConsumerSpec describes a Consumer process instance and its configuration.
// It serves as a allocator MemberValue.
type ConsumerSpec struct {
	// ProcessSpec of the consumer.
	protocol.ProcessSpec `protobuf:"bytes,1,opt,name=process_spec,json=processSpec,embedded=process_spec" json:"process_spec" yaml:",inline"`
	// Maximum number of assigned Shards.
	ShardLimit uint32 `protobuf:"varint,2,opt,name=shard_limit,json=shardLimit,proto3" json:"shard_limit,omitempty"`
}

func (m *ConsumerSpec) Reset()         { *m = ConsumerSpec{} }
func (m *ConsumerSpec) String() string { return proto.CompactTextString(m) }
func (*ConsumerSpec) ProtoMessage()    {}
func (*ConsumerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{1}
}
func (m *ConsumerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsumerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsumerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsumerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumerSpec.Merge(dst, src)
}
func (m *ConsumerSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ConsumerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumerSpec proto.InternalMessageInfo

// ReplicaStatus is the status of a ShardSpec assigned to a ConsumerSpec.
// It serves as a allocator AssignmentValue.
type ReplicaStatus struct {
	Code ReplicaStatus_Code `protobuf:"varint,1,opt,name=code,proto3,enum=consumer.ReplicaStatus_Code" json:"code,omitempty"`
	// Errors encountered during replica processing. Set iff |code| is FAILED.
	Errors []string `protobuf:"bytes,2,rep,name=errors" json:"errors,omitempty"`
}

func (m *ReplicaStatus) Reset()         { *m = ReplicaStatus{} }
func (m *ReplicaStatus) String() string { return proto.CompactTextString(m) }
func (*ReplicaStatus) ProtoMessage()    {}
func (*ReplicaStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{2}
}
func (m *ReplicaStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicaStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReplicaStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaStatus.Merge(dst, src)
}
func (m *ReplicaStatus) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReplicaStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaStatus proto.InternalMessageInfo

type ListRequest struct {
	// Selector optionally refines the set of shards which will be enumerated.
	// If zero-valued, all shards are returned. Otherwise, only ShardSpecs
	// matching the LabelSelector will be returned. One meta-label "id" is
	// additionally supported by the selector, where "id=example-shard-ID"
	// witll match a ShardSpec with ID "example-shard-ID".
	Selector protocol.LabelSelector `protobuf:"bytes,1,opt,name=selector" json:"selector"`
}

func (m *ListRequest) Reset()         { *m = ListRequest{} }
func (m *ListRequest) String() string { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()    {}
func (*ListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{3}
}
func (m *ListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRequest.Merge(dst, src)
}
func (m *ListRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRequest proto.InternalMessageInfo

type ListResponse struct {
	// Status of the List RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	// Header of the response.
	Header protocol.Header      `protobuf:"bytes,2,opt,name=header" json:"header"`
	Shards []ListResponse_Shard `protobuf:"bytes,3,rep,name=shards" json:"shards"`
}

func (m *ListResponse) Reset()         { *m = ListResponse{} }
func (m *ListResponse) String() string { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()    {}
func (*ListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{4}
}
func (m *ListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListResponse.Merge(dst, src)
}
func (m *ListResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListResponse proto.InternalMessageInfo

// Shards of the response.
type ListResponse_Shard struct {
	Spec ShardSpec `protobuf:"bytes,1,opt,name=spec" json:"spec"`
	// Current ModRevision of the ShardSpec.
	ModRevision int64 `protobuf:"varint,2,opt,name=mod_revision,json=modRevision,proto3" json:"mod_revision,omitempty"`
	// Route of the shard, including endpoints.
	Route protocol.Route `protobuf:"bytes,3,opt,name=route" json:"route"`
	// Status of each replica. Cardinality and ordering matches |route|.
	Status []ReplicaStatus `protobuf:"bytes,4,rep,name=status" json:"status"`
}

func (m *ListResponse_Shard) Reset()         { *m = ListResponse_Shard{} }
func (m *ListResponse_Shard) String() string { return proto.CompactTextString(m) }
func (*ListResponse_Shard) ProtoMessage()    {}
func (*ListResponse_Shard) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{4, 0}
}
func (m *ListResponse_Shard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListResponse_Shard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListResponse_Shard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListResponse_Shard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListResponse_Shard.Merge(dst, src)
}
func (m *ListResponse_Shard) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListResponse_Shard) XXX_DiscardUnknown() {
	xxx_messageInfo_ListResponse_Shard.DiscardUnknown(m)
}

var xxx_messageInfo_ListResponse_Shard proto.InternalMessageInfo

type ApplyRequest struct {
	Changes []ApplyRequest_Change `protobuf:"bytes,1,rep,name=changes" json:"changes"`
}

func (m *ApplyRequest) Reset()         { *m = ApplyRequest{} }
func (m *ApplyRequest) String() string { return proto.CompactTextString(m) }
func (*ApplyRequest) ProtoMessage()    {}
func (*ApplyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{5}
}
func (m *ApplyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ApplyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyRequest.Merge(dst, src)
}
func (m *ApplyRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ApplyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyRequest proto.InternalMessageInfo

// Change defines an insertion, update, or deletion to be applied to the set
// of ShardSpecs. Exactly one of |upsert| or |delete| must be set.
type ApplyRequest_Change struct {
	// Expected ModRevision of the current ShardSpec. If the shard is being
	// created, expect_mod_revision is zero.
	ExpectModRevision int64 `protobuf:"varint,1,opt,name=expect_mod_revision,json=expectModRevision,proto3" json:"expect_mod_revision,omitempty"`
	// ShardSpec to be updated (if expect_mod_revision > 0) or created
	// (if expect_mod_revision == 0).
	Upsert *ShardSpec `protobuf:"bytes,2,opt,name=upsert" json:"upsert,omitempty"`
	// Shard to be deleted. expect_mod_revision must not be zero.
	Delete ShardID `protobuf:"bytes,3,opt,name=delete,proto3,casttype=ShardID" json:"delete,omitempty"`
}

func (m *ApplyRequest_Change) Reset()         { *m = ApplyRequest_Change{} }
func (m *ApplyRequest_Change) String() string { return proto.CompactTextString(m) }
func (*ApplyRequest_Change) ProtoMessage()    {}
func (*ApplyRequest_Change) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{5, 0}
}
func (m *ApplyRequest_Change) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyRequest_Change) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyRequest_Change.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ApplyRequest_Change) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyRequest_Change.Merge(dst, src)
}
func (m *ApplyRequest_Change) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ApplyRequest_Change) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyRequest_Change.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyRequest_Change proto.InternalMessageInfo

type ApplyResponse struct {
	// Status of the Update RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	// Header of the response.
	Header protocol.Header `protobuf:"bytes,2,opt,name=header" json:"header"`
}

func (m *ApplyResponse) Reset()         { *m = ApplyResponse{} }
func (m *ApplyResponse) String() string { return proto.CompactTextString(m) }
func (*ApplyResponse) ProtoMessage()    {}
func (*ApplyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_91a0e43787364bdf, []int{6}
}
func (m *ApplyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ApplyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyResponse.Merge(dst, src)
}
func (m *ApplyResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ApplyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ShardSpec)(nil), "consumer.ShardSpec")
	proto.RegisterType((*ShardSpec_Source)(nil), "consumer.ShardSpec.Source")
	proto.RegisterType((*ConsumerSpec)(nil), "consumer.ConsumerSpec")
	proto.RegisterType((*ReplicaStatus)(nil), "consumer.ReplicaStatus")
	proto.RegisterType((*ListRequest)(nil), "consumer.ListRequest")
	proto.RegisterType((*ListResponse)(nil), "consumer.ListResponse")
	proto.RegisterType((*ListResponse_Shard)(nil), "consumer.ListResponse.Shard")
	proto.RegisterType((*ApplyRequest)(nil), "consumer.ApplyRequest")
	proto.RegisterType((*ApplyRequest_Change)(nil), "consumer.ApplyRequest.Change")
	proto.RegisterType((*ApplyResponse)(nil), "consumer.ApplyResponse")
	proto.RegisterEnum("consumer.Status", Status_name, Status_value)
	proto.RegisterEnum("consumer.ReplicaStatus_Code", ReplicaStatus_Code_name, ReplicaStatus_Code_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ShardClient is the client API for Shard service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ShardClient interface {
	// List Shards, their ShardSpecs and their processing status.
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	// Apply changes to the collection of Shards managed by the consumer.
	Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error)
}

type shardClient struct {
	cc *grpc.ClientConn
}

func NewShardClient(cc *grpc.ClientConn) ShardClient {
	return &shardClient{cc}
}

func (c *shardClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, "/consumer.Shard/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardClient) Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error) {
	out := new(ApplyResponse)
	err := c.cc.Invoke(ctx, "/consumer.Shard/Apply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShardServer is the server API for Shard service.
type ShardServer interface {
	// List Shards, their ShardSpecs and their processing status.
	List(context.Context, *ListRequest) (*ListResponse, error)
	// Apply changes to the collection of Shards managed by the consumer.
	Apply(context.Context, *ApplyRequest) (*ApplyResponse, error)
}

func RegisterShardServer(s *grpc.Server, srv ShardServer) {
	s.RegisterService(&_Shard_serviceDesc, srv)
}

func _Shard_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/consumer.Shard/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Shard_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/consumer.Shard/Apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServer).Apply(ctx, req.(*ApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Shard_serviceDesc = grpc.ServiceDesc{
	ServiceName: "consumer.Shard",
	HandlerType: (*ShardServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Shard_List_Handler,
		},
		{
			MethodName: "Apply",
			Handler:    _Shard_Apply_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "consumer.proto",
}

func (m *ShardSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Sources) > 0 {
		for _, msg := range m.Sources {
			dAtA[i] = 0x12
			i++
			i = encodeVarintConsumer(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RecoveryLog) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(len(m.RecoveryLog)))
		i += copy(dAtA[i:], m.RecoveryLog)
	}
	if len(m.HintKeys) > 0 {
		for _, s := range m.HintKeys {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxTxnDuration)))
	n1, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MaxTxnDuration, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x32
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.MinTxnDuration)))
	n2, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MinTxnDuration, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.Disable {
		dAtA[i] = 0x38
		i++
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HotStandbys != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.HotStandbys))
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.LabelSet.ProtoSize()))
	n3, err := m.LabelSet.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *ShardSpec_Source) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardSpec_Source) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Journal) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(len(m.Journal)))
		i += copy(dAtA[i:], m.Journal)
	}
	if m.MinOffset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.MinOffset))
	}
	return i, nil
}

func (m *ConsumerSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.ProcessSpec.ProtoSize()))
	n4, err := m.ProcessSpec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.ShardLimit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.ShardLimit))
	}
	return i, nil
}

func (m *ReplicaStatus) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Code))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ListRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Selector.ProtoSize()))
	n5, err := m.Selector.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *ListResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Status))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Header.ProtoSize()))
	n6, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.Shards) > 0 {
		for _, msg := range m.Shards {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintConsumer(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListResponse_Shard) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResponse_Shard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Spec.ProtoSize()))
	n7, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.ModRevision != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.ModRevision))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Route.ProtoSize()))
	n8, err := m.Route.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Status) > 0 {
		for _, msg := range m.Status {
			dAtA[i] = 0x22
			i++
			i = encodeVarintConsumer(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ApplyRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, msg := range m.Changes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintConsumer(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ApplyRequest_Change) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyRequest_Change) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExpectModRevision != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.ExpectModRevision))
	}
	if m.Upsert != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Upsert.ProtoSize()))
		n9, err := m.Upsert.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Delete) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(len(m.Delete)))
		i += copy(dAtA[i:], m.Delete)
	}
	return i, nil
}

func (m *ApplyResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Status))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Header.ProtoSize()))
	n10, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	return i, nil
}

func encodeVarintConsumer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ShardSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovConsumer(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.ProtoSize()
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	l = len(m.RecoveryLog)
	if l > 0 {
		n += 1 + l + sovConsumer(uint64(l))
	}
	if len(m.HintKeys) > 0 {
		for _, s := range m.HintKeys {
			l = len(s)
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxTxnDuration)
	n += 1 + l + sovConsumer(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MinTxnDuration)
	n += 1 + l + sovConsumer(uint64(l))
	if m.Disable {
		n += 2
	}
	if m.HotStandbys != 0 {
		n += 1 + sovConsumer(uint64(m.HotStandbys))
	}
	l = m.LabelSet.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	return n
}

func (m *ShardSpec_Source) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovConsumer(uint64(l))
	}
	if m.MinOffset != 0 {
		n += 1 + sovConsumer(uint64(m.MinOffset))
	}
	return n
}

func (m *ConsumerSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ProcessSpec.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	if m.ShardLimit != 0 {
		n += 1 + sovConsumer(uint64(m.ShardLimit))
	}
	return n
}

func (m *ReplicaStatus) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovConsumer(uint64(m.Code))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	return n
}

func (m *ListRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Selector.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	return n
}

func (m *ListResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovConsumer(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.ProtoSize()
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	return n
}

func (m *ListResponse_Shard) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Spec.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	if m.ModRevision != 0 {
		n += 1 + sovConsumer(uint64(m.ModRevision))
	}
	l = m.Route.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	if len(m.Status) > 0 {
		for _, e := range m.Status {
			l = e.ProtoSize()
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	return n
}

func (m *ApplyRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.ProtoSize()
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	return n
}

func (m *ApplyRequest_Change) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpectModRevision != 0 {
		n += 1 + sovConsumer(uint64(m.ExpectModRevision))
	}
	if m.Upsert != nil {
		l = m.Upsert.ProtoSize()
		n += 1 + l + sovConsumer(uint64(l))
	}
	l = len(m.Delete)
	if l > 0 {
		n += 1 + l + sovConsumer(uint64(l))
	}
	return n
}

func (m *ApplyResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovConsumer(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	return n
}

func sovConsumer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozConsumer(x uint64) (n int) {
	return sovConsumer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ShardSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, ShardSpec_Source{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveryLog = github_com_LiveRamp_gazette_pkg_protocol.Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HintKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HintKeys = append(m.HintKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTxnDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MaxTxnDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTxnDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MinTxnDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotStandbys", wireType)
			}
			m.HotStandbys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HotStandbys |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LabelSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardSpec_Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = github_com_LiveRamp_gazette_pkg_protocol.Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinOffset", wireType)
			}
			m.MinOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProcessSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardLimit", wireType)
			}
			m.ShardLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ReplicaStatus_Code(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, ListResponse_Shard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse_Shard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModRevision", wireType)
			}
			m.ModRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModRevision |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status, ReplicaStatus{})
			if err := m.Status[len(m.Status)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, ApplyRequest_Change{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyRequest_Change) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectModRevision", wireType)
			}
			m.ExpectModRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectModRevision |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upsert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Upsert == nil {
				m.Upsert = &ShardSpec{}
			}
			if err := m.Upsert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delete = ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConsumer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthConsumer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowConsumer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipConsumer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthConsumer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConsumer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("consumer.proto", fileDescriptor_consumer_91a0e43787364bdf) }

var fileDescriptor_consumer_91a0e43787364bdf = []byte{
	// 1117 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcf, 0x73, 0xdb, 0xc4,
	0x17, 0xb7, 0x6c, 0x47, 0xb6, 0x9f, 0xdc, 0x54, 0xdd, 0xb4, 0x8d, 0xbe, 0x6e, 0xbf, 0x56, 0x2a,
	0x38, 0x78, 0xa0, 0x55, 0x8a, 0xa1, 0x03, 0x64, 0x06, 0x66, 0xec, 0xb8, 0xa5, 0x26, 0xae, 0xd3,
	0x59, 0x9b, 0x03, 0x27, 0x8d, 0x22, 0x6d, 0x6d, 0x51, 0x49, 0x2b, 0xb4, 0x72, 0x27, 0xe6, 0xce,
	0x85, 0x13, 0xc7, 0xde, 0xe0, 0x6f, 0xe0, 0xce, 0xbd, 0xc7, 0x1e, 0x19, 0x0e, 0x66, 0x68, 0xf8,
	0x0b, 0x72, 0xec, 0x89, 0xd1, 0x6a, 0x65, 0x3b, 0x69, 0x98, 0x01, 0x66, 0xb8, 0xe9, 0xbd, 0xf7,
	0x79, 0xbf, 0x3e, 0xef, 0xed, 0x13, 0x6c, 0x3a, 0x34, 0x64, 0xb3, 0x80, 0xc4, 0x66, 0x14, 0xd3,
	0x84, 0xa2, 0x6a, 0x2e, 0x37, 0xee, 0x4c, 0xbc, 0x64, 0x3a, 0x3b, 0x32, 0x1d, 0x1a, 0xec, 0x4e,
	0xe8, 0x84, 0xee, 0x72, 0xc0, 0xd1, 0xec, 0x09, 0x97, 0xb8, 0xc0, 0xbf, 0x32, 0xc7, 0xc6, 0x87,
	0x6b, 0xf0, 0x81, 0xf7, 0x8c, 0x60, 0x3b, 0x88, 0x76, 0x27, 0xf6, 0x37, 0x24, 0x49, 0xc8, 0x6e,
	0xf4, 0x74, 0x92, 0xb9, 0x3b, 0xd4, 0x5f, 0x7e, 0x08, 0xc7, 0xe6, 0x84, 0xd2, 0x89, 0x4f, 0x56,
	0xe1, 0xdd, 0x59, 0x6c, 0x27, 0x1e, 0x0d, 0x33, 0xbb, 0xf1, 0x93, 0x0c, 0xb5, 0xd1, 0xd4, 0x8e,
	0xdd, 0x51, 0x44, 0x1c, 0x74, 0x03, 0x8a, 0x9e, 0xab, 0x49, 0x3b, 0x52, 0xab, 0xd6, 0x55, 0x5e,
	0x2f, 0xf4, 0x0a, 0x37, 0xf5, 0x7b, 0xb8, 0xe8, 0xb9, 0x68, 0x0f, 0x2a, 0x8c, 0xce, 0x62, 0x87,
	0x30, 0xad, 0xb8, 0x53, 0x6a, 0x29, 0xed, 0x86, 0xb9, 0x6c, 0x6f, 0x19, 0xc2, 0x1c, 0x71, 0x48,
	0xb7, 0xfc, 0x62, 0xa1, 0x17, 0x70, 0xee, 0x80, 0x42, 0xa8, 0xc7, 0xc4, 0xa1, 0xcf, 0x48, 0x3c,
	0xb7, 0x7c, 0x3a, 0xd1, 0x4a, 0x3c, 0xc5, 0xc1, 0xe9, 0x42, 0xdf, 0x9a, 0xdb, 0x81, 0xbf, 0x67,
	0xac, 0x5b, 0x8d, 0xd7, 0x0b, 0xfd, 0xee, 0xdf, 0x6d, 0xd8, 0xfc, 0x9c, 0xce, 0xe2, 0xd0, 0xf6,
	0xb1, 0x92, 0x87, 0x18, 0xd0, 0x09, 0x7a, 0x0f, 0x6a, 0x53, 0x2f, 0x4c, 0xac, 0xa7, 0x64, 0xce,
	0xb4, 0xf2, 0x4e, 0xa9, 0x55, 0xeb, 0x5e, 0x3d, 0x5d, 0xe8, 0x6a, 0x96, 0x6c, 0x69, 0x32, 0x70,
	0x35, 0xfd, 0x3e, 0x20, 0x73, 0x86, 0x62, 0x50, 0x03, 0xfb, 0xd8, 0x4a, 0x8e, 0x43, 0x2b, 0xe7,
	0x48, 0xdb, 0xd8, 0x91, 0x5a, 0x4a, 0xfb, 0x7f, 0x66, 0x46, 0xa2, 0x99, 0x93, 0x68, 0xf6, 0x04,
	0xa0, 0x7b, 0x27, 0x6d, 0xf3, 0x74, 0xa1, 0xdf, 0xca, 0x02, 0x9f, 0x0f, 0x70, 0x9b, 0x06, 0x5e,
	0x42, 0x82, 0x28, 0x99, 0x1b, 0xcf, 0x7f, 0xd3, 0x25, 0xbc, 0x19, 0xd8, 0xc7, 0xe3, 0xe3, 0x30,
	0x77, 0xe7, 0x39, 0xbd, 0xf0, 0x6c, 0x4e, 0xf9, 0x9f, 0xe6, 0x3c, 0x17, 0xe0, 0xcd, 0x9c, 0x5e,
	0xb8, 0x9e, 0x53, 0x83, 0x8a, 0xeb, 0x31, 0xfb, 0xc8, 0x27, 0x5a, 0x65, 0x47, 0x6a, 0x55, 0x71,
	0x2e, 0xa2, 0x3d, 0xa8, 0x4f, 0x69, 0x62, 0xb1, 0xc4, 0x0e, 0xdd, 0xa3, 0x39, 0xd3, 0xaa, 0x3b,
	0x52, 0xeb, 0x52, 0x77, 0x7b, 0x35, 0xa4, 0x75, 0xab, 0x81, 0x95, 0x29, 0x4d, 0x46, 0x42, 0x42,
	0x8f, 0x41, 0xf6, 0xed, 0x23, 0xe2, 0x33, 0xad, 0xc6, 0xeb, 0x47, 0xe6, 0x72, 0x40, 0x83, 0x54,
	0x3f, 0x22, 0x49, 0xf7, 0xed, 0xb4, 0xf0, 0x97, 0x0b, 0x5d, 0x3a, 0x5d, 0xe8, 0x5a, 0x16, 0x71,
	0x55, 0xec, 0x6d, 0x2f, 0xf4, 0xbd, 0x90, 0x18, 0x58, 0xc4, 0x69, 0x3c, 0x97, 0x40, 0xce, 0x96,
	0x09, 0x0d, 0xa1, 0xf2, 0x55, 0x36, 0x65, 0xb1, 0x9b, 0x1f, 0xfc, 0xab, 0x0d, 0xc9, 0x83, 0xa0,
	0x4f, 0x01, 0x52, 0xd6, 0xe8, 0x93, 0x27, 0x8c, 0x24, 0x7c, 0x17, 0x4b, 0x5d, 0xfd, 0x74, 0xa1,
	0xdf, 0x58, 0x31, 0x9a, 0xd9, 0xd6, 0xb8, 0xc4, 0xb5, 0xc0, 0x0b, 0x0f, 0xb9, 0xd6, 0xf8, 0x56,
	0x82, 0xfa, 0xbe, 0x58, 0x7d, 0xfe, 0x6e, 0xc6, 0x50, 0x8f, 0x62, 0xea, 0x10, 0xc6, 0x2c, 0x16,
	0x11, 0x87, 0x57, 0xa9, 0xb4, 0xaf, 0xad, 0x38, 0x78, 0x9c, 0x59, 0x53, 0x70, 0xb7, 0xb1, 0x46,
	0xc3, 0xa6, 0xa0, 0x21, 0x6f, 0x5e, 0x89, 0x56, 0x40, 0xa4, 0x83, 0xc2, 0xd2, 0x77, 0x65, 0xf9,
	0x5e, 0xe0, 0x25, 0x5a, 0x31, 0x1d, 0x07, 0x06, 0xae, 0x1a, 0xa4, 0x1a, 0xe3, 0x07, 0x09, 0x2e,
	0x61, 0x12, 0xf9, 0x9e, 0x63, 0x8f, 0x12, 0x3b, 0x99, 0x31, 0x74, 0x17, 0xca, 0x0e, 0x75, 0x09,
	0x2f, 0x60, 0xb3, 0x7d, 0x73, 0xf5, 0x40, 0xcf, 0xc0, 0xcc, 0x7d, 0xea, 0x12, 0xcc, 0x91, 0xe8,
	0x3a, 0xc8, 0x24, 0x8e, 0x69, 0x9c, 0x3d, 0xea, 0x1a, 0x16, 0x92, 0xd1, 0x83, 0x72, 0x8a, 0x42,
	0x55, 0x28, 0xf7, 0x7b, 0x83, 0xfb, 0x6a, 0x01, 0xd5, 0xa1, 0xda, 0xed, 0xec, 0x1f, 0x3c, 0xe8,
	0x0f, 0x06, 0xaa, 0x84, 0x14, 0xa8, 0x8c, 0x3b, 0xfd, 0x41, 0x7f, 0xf8, 0x99, 0x5a, 0x4c, 0x85,
	0xc7, 0xb8, 0xff, 0xa8, 0x83, 0xbf, 0x54, 0x4b, 0x08, 0x40, 0x7e, 0xd0, 0xe9, 0x0f, 0xee, 0xf7,
	0xd4, 0xb2, 0xf1, 0x10, 0x94, 0x81, 0xc7, 0x12, 0x4c, 0xbe, 0x9e, 0x11, 0x96, 0xa0, 0x8f, 0xa1,
	0xca, 0x88, 0x4f, 0x9c, 0x84, 0xc6, 0x82, 0xa3, 0xed, 0x37, 0xf6, 0x24, 0x33, 0x8b, 0x03, 0xb2,
	0x84, 0x1b, 0x7f, 0x14, 0xa1, 0x9e, 0x85, 0x62, 0x11, 0x0d, 0x19, 0x41, 0x2d, 0x90, 0x19, 0xef,
	0x46, 0x34, 0xab, 0xae, 0x5d, 0x23, 0xae, 0xc7, 0xc2, 0x8e, 0x4c, 0x90, 0xa7, 0xc4, 0x76, 0x49,
	0xcc, 0x29, 0x54, 0xda, 0xea, 0x2a, 0xe7, 0x43, 0xae, 0x17, 0xc9, 0x04, 0x0a, 0xed, 0x81, 0xcc,
	0x49, 0x66, 0x5a, 0x89, 0xdf, 0xb9, 0x35, 0x1a, 0xd7, 0x2b, 0xc8, 0x8e, 0x5e, 0xee, 0x9b, 0x79,
	0x34, 0x7e, 0x96, 0x60, 0x83, 0xeb, 0xd1, 0x1d, 0x28, 0xaf, 0xed, 0xc2, 0xd6, 0x05, 0xb7, 0x52,
	0xb8, 0x72, 0x18, 0xba, 0x05, 0xf5, 0x80, 0xba, 0x56, 0x4c, 0x9e, 0x79, 0x2c, 0x3d, 0x03, 0x69,
	0xa9, 0x25, 0xac, 0x04, 0xd4, 0xc5, 0x42, 0x85, 0xde, 0x85, 0x8d, 0x98, 0xce, 0x12, 0xc2, 0x37,
	0x56, 0x69, 0x5f, 0x5e, 0xb5, 0x81, 0x53, 0xb5, 0x08, 0x97, 0x61, 0xd0, 0xbd, 0x25, 0x3d, 0x65,
	0xde, 0xc4, 0xf6, 0x5f, 0xec, 0xc2, 0xb2, 0x7e, 0x2e, 0x19, 0xbf, 0x4a, 0x50, 0xef, 0x44, 0x91,
	0x3f, 0xcf, 0x47, 0xf6, 0x09, 0x54, 0x9c, 0xa9, 0x1d, 0x4e, 0x48, 0xca, 0x73, 0x1a, 0xe8, 0xff,
	0xab, 0x40, 0xeb, 0x40, 0x73, 0x9f, 0xa3, 0xf2, 0xc3, 0x2f, 0x7c, 0x1a, 0xdf, 0x49, 0x20, 0x67,
	0x16, 0x64, 0xc2, 0x16, 0x39, 0x8e, 0x88, 0x93, 0x58, 0x67, 0x1a, 0x95, 0x78, 0xa3, 0x57, 0x32,
	0xd3, 0xa3, 0x33, 0xed, 0xca, 0xb3, 0x88, 0x91, 0x38, 0x11, 0x63, 0xbb, 0x88, 0x42, 0x2c, 0x20,
	0xe8, 0x2d, 0x90, 0x5d, 0xe2, 0x13, 0x41, 0xce, 0xb9, 0xbf, 0x97, 0x30, 0x19, 0x1e, 0x5c, 0x12,
	0x25, 0xff, 0xd7, 0x3b, 0xf4, 0x0e, 0x05, 0x59, 0x3c, 0x49, 0x19, 0x8a, 0x87, 0x07, 0x6a, 0x01,
	0x6d, 0xc1, 0xe5, 0xd1, 0xc3, 0x0e, 0xee, 0x59, 0xc3, 0xc3, 0xb1, 0xf5, 0xe0, 0xf0, 0x8b, 0x61,
	0x4f, 0x95, 0xd0, 0x55, 0x50, 0x87, 0x87, 0x56, 0xa6, 0xcf, 0x5f, 0x50, 0x11, 0x5d, 0x83, 0x2b,
	0x29, 0xe8, 0xac, 0xba, 0x84, 0x6e, 0xc0, 0xf6, 0xfd, 0xf1, 0x7e, 0xcf, 0x1a, 0xe3, 0xce, 0x70,
	0xd4, 0xd9, 0x1f, 0xf7, 0x0f, 0x87, 0x56, 0xfe, 0xd2, 0xda, 0xc7, 0xf9, 0xde, 0xdd, 0x83, 0x72,
	0xba, 0xa5, 0xe8, 0xda, 0xf9, 0xad, 0xe5, 0x63, 0x6a, 0x5c, 0xbf, 0x78, 0x99, 0xd1, 0x47, 0xb0,
	0xc1, 0xb9, 0x41, 0xd7, 0x2f, 0x9e, 0x6f, 0x63, 0xfb, 0x0d, 0x7d, 0xe6, 0xd9, 0xbd, 0xf9, 0xe2,
	0xf7, 0x66, 0xe1, 0xc5, 0xab, 0xa6, 0xf4, 0xf2, 0x55, 0x53, 0xfa, 0xfe, 0xa4, 0x59, 0xf8, 0xf1,
	0xa4, 0x29, 0xbd, 0x3c, 0x69, 0x16, 0x7e, 0x39, 0x69, 0x16, 0x8e, 0x64, 0xce, 0xd3, 0xfb, 0x7f,
	0x06, 0x00, 0x00, 0xff, 0xff, 0x26, 0x7a, 0x5f, 0xd5, 0x0b, 0x09, 0x00, 0x00,
}
